:spring-data-commons-ref: https://docs.spring.io/spring-data/data-commons/docs/current/reference/html

== Spring Data Spanner

=== Spring Data and Google Cloud Spanner

http://projects.spring.io/spring-data/[Spring Data]
is an abstraction for storing and retrieving POJOs in numerous storage technologies.
Spring Cloud GCP adds Spring Data support for http://cloud.google.com/spanner/[Google Cloud Spanner].

A Spring Boot starter is provided to auto-configure the various Storage components.

Maven coordinates for the Spring Boot Starter for Spanner, using Spring Cloud GCP BOM:

[source,xml]
----
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-gcp-starter-data-spanner</artifactId>
</dependency>
----

Gradle coordinates:

[source,subs="normal"]
----
dependencies {
    compile group: 'org.springframework.cloud', name: 'spring-cloud-gcp-starter-data-spanner'
}
----

This setup takes care of bringing in the latest compatible version of Cloud Java Spanner libraries as well.


=== Configuration

To setup Spring Data Spanner, you have to configure connection to Cloud Spanner and Repositories (if you want to use them).

==== Spanner settings

You will need to use link:../spring-cloud-gcp-starters/spring-cloud-gcp-starter-data-spanner[Spring Boot Starter for Spring Data Spanner] to configure Google Cloud Spanner in your Spring application. It contains all the necessary setup that makes it easy to authenticate with your Google Cloud project.
The following configuration options are available:

|===
| Name | Description | Optional | Default value
| `spring.cloud.gcp.spanner.projectId` | the GCP project ID to use | Yes | provided by Spring Cloud GCP
| `spring.cloud.gcp.spanner.instanceId` | Spanner instance to use | No |
| `spring.cloud.gcp.spanner.database` |
Spanner database to use | No |
|===

==== Repository settings

Spring Data Repositories (see below for functionality) can be configured via the `@EnableSpannerRepositories` annotation on your main configuration file (typically the `@SpringBootApplication` file.

==== Available beans

With our Spring Boot autoconfiguration your application is able to inject an instance of `DatabaseClient` and `SpannerOperations`, and when repositories are enabled, all the user defined repositories extending `SpannerRepository` are exposed as beans as well.


=== Mapping POJO domain objects to Spanner tables using annotations

Spring Data Spanner allows you to map POJOs to Spanner tables:

[source,java]
----
@Table(name = "trades")
public class Trade {

	@PrimaryKeyColumn(keyOrder = 2)
	String action;

	Double price;

	Double shares;

	@PrimaryKeyColumn(keyOrder = 1)
	String symbol;

	@Column(name = "trader_id")
	String traderId;

	@ColumnInnerType(innerType = Double.class)
	List<Double> curve;
}
----

- `@Table` provides the name of the Spanner table that stores instances of this class, one per row.
- `@PrimaryKeyColumn` annotation is required and identifies the properties corresponding to the primary key columns in
order starting with 1 and increasing consecutively.
- The `@Column` annotation optionally provides a different column name than that of the property.
- Spanner supports `List` types as fields, the `@ColumnInnerType` annotation is required for `List` properties due to Java's type erasure.

#### SpEL expressions for table names

In some cases you might want the `@Table` table name to be determined dynamically. In this case, you can use https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions[Spring Expression Language].

For example:

[source, java]
----

@Table(name = "trades_#{tableNameSuffix}")
public class Trade {
	// ...
}
----

This table name will be resolved only if `tableNameSuffix` value/bean in the Spring `applicationContext` is defined, and then, for exapmle if it has the value "123", it will be `trades_123`.

=== Template API

`SpannerOperations` and its implementation, `SpannerTemplate` provides the XYZTemplate pattern familiar for Spring developers and as such provides:

 - resource management
 - one stop shop to Spanner operations with the Spring Data POJO mapping and conversion features
 - exception conversion

After your setup with Spring Boot Starter, you can configure a template simply by injecting a member of the `SpannerOperations` interface to your class:

[source,java]
----
@SpringBootApplication
public class SpannerTemplateExample {

	@Autowired
	SpannerOperations spannerTemplate;

  public void doSomething() {
			this.spannerOperations.delete(Trade.class, KeySet.all());
			//...
			Trade t = new Trade();
			//...
			this.spannerOperations.insert(t);
			//...
			List<Trade> tradesByAction = spannerOperations.findAll(Trade.class);
			//...
	}
}
----

The Template API provides convenience methods for:

- https://cloud.google.com/spanner/docs/reads[Reads], and by providing SpannerReadOptions and SpannerQueryOptions
   ** Stale read
   ** Read with secondary indices
   ** Read with limits and flow control
- https://cloud.google.com/spanner/docs/reads#execute_a_query[Queries]
- DML operations (delete, insert, update, upsert)
- partial reads: you can define a set of columns to be read into your entity
- partial writes: if you have only a few properties that you want to persist from your entity, you can select those


=== Supported Types

Spring Data Spanner supports the following types for regular fields:

* `com.google.cloud.ByteArray`
* `com.google.cloud.Date`
* `com.google.cloud.Timestamp`
* `java.lang.Boolean`
* `java.lang.Long`
* `java.lang.String`
* `double[]`
* `long[]`
* `boolean[]`

Spring Data Spanner supports the following inner types for `List` fields:

* `com.google.cloud.ByteArray`
* `com.google.cloud.Date`
* `com.google.cloud.Timestamp`
* `java.lang.Boolean`
* `java.lang.Long`
* `java.lang.String`


=== Repositories

{spring-data-commons-ref}/#repositories[Spring Data Repositories] are a powerful abstraction that can save you a lot of typing.
For Spring Data Spanner, the code inheriting `SpannerRepository` gets all the benefits of `CrudRepository` and `PagingAndSortingRepository` as well, meaning you get by default a lot of generated methods, ready to use.

For example:

[source,java]
----
public interface TradeRepository extends SpannerRepository<Trade> {

	List<Trade> findByAction(String action);

	int countByAction(String action);

	//named method are powerful but can get unwieldy
	List<Trade> findTop3DistinctByActionAndSymbolOrTraderIdOrderBySymbolDesc(
  			String action, String symbol, String traderId);

	// This method uses the query from the properties file instead of one generated based on name.
	List<Trade> fetchByActionNamedQuery(String action);

}
----

This repository can be used without an actual implementation!

[source,java]
----
@EnableSpannerRepositories(namedQueriesLocation = "classpath:/spanner-named-queries.properties")
public class MyApplication {

	@Autowired
	SpannerOperations spannerOperations;

	@Autowired
	StudentRepository studentRepository;

	public void demo() {

		this.tradeRepository.deleteAll(); //defined on CrudRepository
		String traderId = "demo_trader";
		Trade t = new Trade();
		t.symbol = stock;
		t.action = action;
		t.traderId = traderId;
		t.price = 100.0;
		t.shares = 12345.6;
		this.spannerOperations.insert(t); //defined on CrudRepository

		Iterable<Trade> allTrades = this.tradeRepository.findAll(); //defined on CrudRepository

		int count = this.tradeRepository.countByAction("BUY");

	}
}

----

=== Query methods


==== Resolving methods by name

In the example above, the {spring-data-commons-ref}/#repositories.query-methods[query methods]
in `TradeRepository` are generated based on the convention of their names.

`List<Trade> findByAction(String action)` would translate to a `SELECT * FROM trades WHERE action = ?`.

You can think about the little bit extreme `List<Trade> findTop3DistinctByActionAndSymbolOrTraderIdOrderBySymbolDesc(String action, String symbol, String traderId);` as

[source, sql]
----
SELECT DISTINCT * FROM trades
WHERE ACTION = ? AND SYMBOL = ? AND Or TRADER_ID = ?
ORDER BY SYMBOL DESC
LIMIT 3
----

==== Mapping SQL to repository methods using properties file


In the example above for `List<Trade> fetchByActionNamedQuery(String action)` does not match the naming convention.
The query for it is defined in the `spanner-named-queries.properties` file

[source, properties]
----
Trade.fetchByActionNamedQuery=SELECT * FROM trades WHERE trades.action = @tag0`
----

==== Mapping SQL to repository methods using annotation

TODO
